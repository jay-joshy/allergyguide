var DosingStrategy, FoodType, Method, FoodAStrategy; "undefined" != typeof Decimal && Decimal.set({ precision: 20, rounding: Decimal.ROUND_HALF_UP }), function(e) { e.STANDARD = "STANDARD", e.SLOW = "SLOW", e.RAPID = "RAPID" }(DosingStrategy || (DosingStrategy = {})), function(e) { e.SOLID = "SOLID", e.LIQUID = "LIQUID" }(FoodType || (FoodType = {})), function(e) { e.DILUTE = "DILUTE", e.DIRECT = "DIRECT" }(Method || (Method = {})), function(e) { e.DILUTE_INITIAL = "DILUTE_INITIAL", e.DILUTE_ALL = "DILUTE_ALL", e.DILUTE_NONE = "DILUTE_NONE" }(FoodAStrategy || (FoodAStrategy = {})); const DOSING_STRATEGIES = { STANDARD: [1, 2.5, 5, 10, 20, 40, 80, 120, 160, 240, 300], SLOW: [.5, 1, 1.5, 2.5, 5, 10, 20, 30, 40, 60, 80, 100, 120, 140, 160, 190, 220, 260, 300], RAPID: [5, 10, 20, 40, 80, 160, 300] }, SOLID_MIX_CANDIDATES = [.2, .25, .3, .35, .4, .45, .5, 1, 2, 5, 10], LIQUID_MIX_CANDIDATES = [.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 6, 7, 8, 9, 10], DAILY_AMOUNT_CANDIDATES = [.5, 1, 1.5, 2, 2.5, 3, 4, 5, 7, 9, 10, 11, 12], MAX_MIX_WATER = 250; let DEFAULT_CONFIG; DEFAULT_CONFIG = { minMeasurableMass: new Decimal(.2), minMeasurableVolume: new Decimal(.2), minServingsForMix: new Decimal(3), PROTEIN_TOLERANCE_MG: new Decimal(.5), DEFAULT_FOOD_A_DILUTION_THRESHOLD: new Decimal(.2), DEFAULT_FOOD_B_THRESHOLD: new Decimal(.2), MAX_SOLID_CONCENTRATION: new Decimal(.05) }; let currentProtocol = null, foodsDatabase = [], protocolsDatabase = [], fuzzySortPreparedFoods = [], fuzzySortPreparedProtocols = [], customNote = "", searchDebounceTimer = null, editDebounceTimer = null, currentDropdownIndex = -1, currentDropdownInputId = ""; function escapeHtml(e) { return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;") } function mgPer100ToMgPerUnit(e, o) { return new Decimal(e).times(1e3).dividedBy(100) } function mgPerUnitToMgPer100(e) { return e.times(100).dividedBy(1e3).toNumber() } function formatNumber(e, o) { if (null == e) return ""; return ("number" == typeof e ? e : e.toNumber()).toFixed(o) } function formatAmount(e, o) { if (null == e) return ""; const t = "number" == typeof e ? e : e.toNumber(); return "g" === o ? t.toFixed(2) : t % 1 == 0 ? t.toFixed(0) : t.toFixed(1) } function getMeasuringUnit(e) { return e.type === FoodType.LIQUID ? "ml" : "g" } function findDilutionCandidates(e, o, t) { const n = [], r = o.type === FoodType.SOLID ? SOLID_MIX_CANDIDATES : LIQUID_MIX_CANDIDATES, d = o.type === FoodType.SOLID ? e.dividedBy(t.MAX_SOLID_CONCENTRATION.times(o.mgPerUnit)) : null; for (const d of r) { const r = new Decimal(d); for (const d of DAILY_AMOUNT_CANDIDATES) { const a = new Decimal(d); if (o.type === FoodType.SOLID) { const d = r.times(o.mgPerUnit), s = d.dividedBy(e); if (s.lessThan(t.minServingsForMix)) continue; const i = a.times(s), l = i; if (r.lessThan(t.minMeasurableMass)) continue; if (a.lessThan(t.minMeasurableVolume)) continue; if (l.greaterThan(MAX_MIX_WATER)) continue; if (l.lessThan(t.minMeasurableVolume)) continue; if (d.dividedBy(i).times(a).minus(e).abs().greaterThan(t.PROTEIN_TOLERANCE_MG)) continue; n.push({ mixFoodAmount: r, mixWaterAmount: l, dailyAmount: a, mixTotalVolume: i, servings: s }) } else { const d = r.times(o.mgPerUnit), s = d.dividedBy(e); if (s.lessThan(t.minServingsForMix)) continue; const i = a.times(s), l = i.minus(r); if (l.lessThan(0)) continue; if (r.lessThan(t.minMeasurableVolume)) continue; if (a.lessThan(t.minMeasurableVolume)) continue; if (l.greaterThan(MAX_MIX_WATER)) continue; if (l.lessThan(t.minMeasurableVolume)) continue; if (d.dividedBy(i).times(a).minus(e).abs().greaterThan(t.PROTEIN_TOLERANCE_MG)) continue; n.push({ mixFoodAmount: r, mixWaterAmount: l, dailyAmount: a, mixTotalVolume: i, servings: s }) } } } return n.sort(((e, t) => { if (o.type === FoodType.SOLID && d) { const o = e.dailyAmount.greaterThanOrEqualTo(d), n = t.dailyAmount.greaterThanOrEqualTo(d); if (o && !n) return -1; if (!o && n) return 1 } let n = e.mixFoodAmount.comparedTo(t.mixFoodAmount); return 0 !== n ? n : (n = e.dailyAmount.comparedTo(t.dailyAmount), 0 !== n ? n : (n = e.mixTotalVolume.comparedTo(t.mixTotalVolume), 0 !== n ? n : e.mixWaterAmount.comparedTo(t.mixWaterAmount))) })), n } function generateStepForTarget(e, o, t, n, r, d) { const a = new Decimal(e), s = a.dividedBy(t.mgPerUnit), i = t.type === FoodType.SOLID ? "g" : "ml"; let l = !1; if (l = n === FoodAStrategy.DILUTE_INITIAL ? s.lessThan(r) : n === FoodAStrategy.DILUTE_ALL, l) { const e = findDilutionCandidates(a, t, d); if (0 === e.length) return null; const n = e[0]; return { stepIndex: o, targetMg: a, method: Method.DILUTE, dailyAmount: n.dailyAmount, dailyAmountUnit: "ml", mixFoodAmount: n.mixFoodAmount, mixWaterAmount: n.mixWaterAmount, servings: n.servings, food: "A" } } return { stepIndex: o, targetMg: a, method: Method.DIRECT, dailyAmount: s, dailyAmountUnit: i, food: "A" } } function generateDefaultProtocol(e, o) { const t = DosingStrategy.STANDARD, n = FoodAStrategy.DILUTE_INITIAL, r = e.type === FoodType.SOLID ? "g" : "ml", d = DEFAULT_CONFIG.DEFAULT_FOOD_A_DILUTION_THRESHOLD, a = DOSING_STRATEGIES[t], s = []; for (let t = 0; t < a.length; t++) { const i = generateStepForTarget(a[t], t + 1, e, n, d, o); if (i) s.push(i); else { const o = new Decimal(a[t]), n = o.dividedBy(e.mgPerUnit); s.push({ stepIndex: t + 1, targetMg: o, method: Method.DIRECT, dailyAmount: n, dailyAmountUnit: r, food: "A" }) } } return { dosingStrategy: t, foodA: e, foodAStrategy: n, diThreshold: d, steps: s, config: o } } function getFoodAStepCount(e) { if (!e.foodB) return e.steps.length; for (let o = 0; o < e.steps.length; o++)if ("B" === e.steps[o].food) return o; return e.steps.length } function addFoodBToProtocol(e, o, t) { const n = t.amount.times(o.mgPerUnit); e.foodB = o, e.foodBThreshold = t; let r = -1; for (let o = 0; o < e.steps.length; o++)if (e.steps[o].targetMg.greaterThanOrEqualTo(n)) { r = o; break } if (-1 === r) return void console.warn("No transition point found for Food B"); const d = []; for (let o = r + 1; o < e.steps.length; o++)d.push(e.steps[o].targetMg); const a = e.steps[r].targetMg, s = [], i = o.type === FoodType.SOLID ? "g" : "ml", l = a, c = l.dividedBy(o.mgPerUnit); s.push({ stepIndex: r + 2, targetMg: l, method: Method.DIRECT, dailyAmount: c, dailyAmountUnit: i, food: "B" }); for (const e of d) { const t = e.dividedBy(o.mgPerUnit); s.push({ stepIndex: 0, targetMg: e, method: Method.DIRECT, dailyAmount: t, dailyAmountUnit: i, food: "B" }) } e.steps = e.steps.slice(0, r + 1), e.steps.push(...s); for (let o = 0; o < e.steps.length; o++)e.steps[o].stepIndex = o + 1 } function validateProtocol(e) { var o, t; const n = []; e.steps.length < 5 && n.push({ severity: "red", code: "R1", message: "Protocol < 5 steps, which is quite rapid for a full OIT protocol." }), e.foodA.mgPerUnit.lessThanOrEqualTo(new Decimal(0)) && n.push({ severity: "red", code: "R7", message: `${escapeHtml(e.foodA.name)} protein concentration must be > 0 to be considered for OIT` }), (null === (o = e.foodB) || void 0 === o ? void 0 : o.mgPerUnit.lessThanOrEqualTo(new Decimal(0))) && n.push({ severity: "red", code: "R7", message: `${escapeHtml((null === (t = e.foodB) || void 0 === t ? void 0 : t.name) || "")} protein concentration must be > 0 to be considered for OIT` }); for (const o of e.steps) { const t = "B" === o.food ? e.foodB : e.foodA; if (o.targetMg.lessThanOrEqualTo(new Decimal(0)) && n.push({ severity: "red", code: "R8", message: `Step ${o.stepIndex}: A target protein of ${formatNumber(o.targetMg, 1)} mg is NOT valid. It must be >0.`, stepIndex: o.stepIndex }), o.method === Method.DILUTE) { const r = o.mixFoodAmount.times(t.mgPerUnit), d = t.type === FoodType.SOLID ? o.mixWaterAmount : o.mixFoodAmount.plus(o.mixWaterAmount), a = r.times(o.dailyAmount).dividedBy(d); if (a.minus(o.targetMg).abs().greaterThan(.5) && n.push({ severity: "red", code: "R2", message: `Step ${o.stepIndex}: Protein mismatch. Target ${formatNumber(o.targetMg, 1)} mg but calculated ${formatNumber(a, 1)} mg.`, stepIndex: o.stepIndex }), o.servings.lessThan(new Decimal(1))) { const e = o.mixFoodAmount.times(t.mgPerUnit); n.push({ severity: "red", code: "R5", message: `Step ${o.stepIndex}: ${formatNumber(o.mixFoodAmount, 2)} ${getMeasuringUnit(t)} of food only makes ${formatNumber(e, 1)} mg of total protein. However, target protein is ${formatNumber(o.targetMg, 1)} mg.`, stepIndex: o.stepIndex }) } d.lessThan(o.dailyAmount) && n.push({ severity: "red", code: "R6", message: `Step ${o.stepIndex}: Total volume of dilution is ${formatNumber(d, 1)} ml; however, daily amount is ${formatNumber(o.dailyAmount, 1)} ml, which is impossible`, stepIndex: o.stepIndex }), o.dailyAmount.lessThanOrEqualTo(0) && n.push({ severity: "red", code: "R9", message: `Step ${o.stepIndex}: Daily amount cannot be <= 0 ml`, stepIndex: o.stepIndex }), o.mixFoodAmount.lessThanOrEqualTo(0) && n.push({ severity: "red", code: "R9", message: `Step ${o.stepIndex}: Amount of food to mix cannot be <= 0 ${getMeasuringUnit(t)}`, stepIndex: o.stepIndex }), o.mixWaterAmount.lessThan(0) && n.push({ severity: "red", code: "R9", message: `Step ${o.stepIndex}: Amount of water to mix cannot be < 0 ml`, stepIndex: o.stepIndex }), t.type === FoodType.SOLID && o.mixFoodAmount.lessThan(e.config.minMeasurableMass) && n.push({ severity: "yellow", code: "Y3", message: `Step ${o.stepIndex}: Measuring ${formatNumber(o.mixFoodAmount, 2)} g of food is impractical. Aim for value >=${e.config.minMeasurableMass} g`, stepIndex: o.stepIndex }), t.type === FoodType.LIQUID && o.mixFoodAmount.lessThan(e.config.minMeasurableVolume) && n.push({ severity: "yellow", code: "Y3", message: `Step ${o.stepIndex}: Measuring ${formatNumber(o.mixFoodAmount, 1)} ml of food is impractical. Aim for value >=${e.config.minMeasurableVolume} ml`, stepIndex: o.stepIndex }), o.dailyAmount.lessThan(e.config.minMeasurableVolume) && n.push({ severity: "yellow", code: "Y3", message: `Step ${o.stepIndex}: Measuring a daily amount of ${formatNumber(o.dailyAmount, 1)} ml is impractical. Aim for value >=${e.config.minMeasurableVolume} ml`, stepIndex: o.stepIndex }), o.mixWaterAmount.lessThan(e.config.minMeasurableVolume) && n.push({ severity: "yellow", code: "Y3", message: `Step ${o.stepIndex}: Measuring ${formatNumber(o.mixWaterAmount, 1)} ml of water is impractical. Aim for value >=${e.config.minMeasurableVolume} ml`, stepIndex: o.stepIndex }), o.servings.lessThan(e.config.minServingsForMix) && o.servings.greaterThan(new Decimal(1)) && n.push({ severity: "yellow", code: "Y1", message: `Step ${o.stepIndex}: Only ${formatNumber(o.servings, 1)} servings (< ${DEFAULT_CONFIG.minServingsForMix} - impractical). Consider increasing mix amounts.`, stepIndex: o.stepIndex }), t.type === FoodType.SOLID && o.mixFoodAmount.dividedBy(o.mixWaterAmount).greaterThan(new Decimal(.05)) && n.push({ severity: "yellow", code: "Y4", message: `Step ${o.stepIndex}: at ${formatNumber(o.mixFoodAmount, 2)} g of food in ${formatNumber(o.mixWaterAmount, 1)} ml of water, the ratio of food:water is >1:20. The assumption that the food contributes non-negligibly to the total volume of dilution is likely violated. Consider increasing the Daily Amount`, stepIndex: o.stepIndex }) } else if (o.method === Method.DIRECT) { const r = o.dailyAmount.times(t.mgPerUnit); r.minus(o.targetMg).abs().greaterThan(.5) && n.push({ severity: "red", code: "R2", message: `Step ${o.stepIndex}: Protein mismatch. Target ${formatNumber(o.targetMg, 1)} mg but calculated ${formatNumber(r, 1)} mg.`, stepIndex: o.stepIndex }), t.type === FoodType.SOLID && o.dailyAmount.lessThan(e.config.minMeasurableMass) && n.push({ severity: "yellow", code: "Y3", message: `Step ${o.stepIndex}: Measuring ${formatNumber(o.dailyAmount, 2)} g of food is impractical. Aim for >=${e.config.minMeasurableMass} g`, stepIndex: o.stepIndex }), t.type === FoodType.LIQUID && o.dailyAmount.lessThan(e.config.minMeasurableVolume) && n.push({ severity: "yellow", code: "Y3", message: `Step ${o.stepIndex}: Measuring ${formatNumber(o.dailyAmount, 1)} ml of food is impractical. Aim for >=${e.config.minMeasurableVolume} ml`, stepIndex: o.stepIndex }) } } for (let o = 1; o < e.steps.length; o++)e.steps[o].targetMg.lessThan(e.steps[o - 1].targetMg) && n.push({ severity: "yellow", code: "Y2", message: `Steps must be ascending or equal — check step ${e.steps[o].stepIndex} vs step ${e.steps[o - 1].stepIndex}.`, stepIndex: e.steps[o].stepIndex }); return n } function recalculateProtocol() { if (!currentProtocol) return; const e = DOSING_STRATEGIES[currentProtocol.dosingStrategy], o = []; for (let t = 0; t < e.length; t++) { const n = generateStepForTarget(e[t], t + 1, currentProtocol.foodA, currentProtocol.foodAStrategy, currentProtocol.diThreshold, currentProtocol.config); n && o.push(n) } currentProtocol.steps = o, currentProtocol.foodB && currentProtocol.foodBThreshold && addFoodBToProtocol(currentProtocol, currentProtocol.foodB, currentProtocol.foodBThreshold), renderProtocolTable(), updateWarnings() } function recalculateStepMethods() { if (!currentProtocol) return; const e = currentProtocol.steps.map((e => e.targetMg)), o = currentProtocol.steps.map((e => e.food)), t = (getFoodAStepCount(currentProtocol), []); for (let n = 0; n < e.length; n++) { const r = e[n], d = "B" === o[n], a = generateStepForTarget(r, n + 1, d ? currentProtocol.foodB : currentProtocol.foodA, d ? FoodAStrategy.DILUTE_NONE : currentProtocol.foodAStrategy, currentProtocol.diThreshold, currentProtocol.config); a && (a.food = o[n], t.push(a)) } currentProtocol.steps = t, renderProtocolTable(), updateWarnings() } function updateStepTargetMg(e, o) { if (!currentProtocol) return; const t = currentProtocol.steps[e - 1]; if (!t) return; t.targetMg = new Decimal(o); const n = "B" === t.food ? currentProtocol.foodB : currentProtocol.foodA; if (t.method === Method.DIRECT) t.dailyAmount = t.targetMg.dividedBy(n.mgPerUnit); else { const e = t.mixFoodAmount.times(n.mgPerUnit); if (t.servings = e.dividedBy(t.targetMg), n.type === FoodType.SOLID) { const e = t.dailyAmount.times(t.servings); t.mixWaterAmount = e } else { const e = t.dailyAmount.times(t.servings); t.mixWaterAmount = e.minus(t.mixFoodAmount) } } renderProtocolTable(), updateWarnings() } function updateStepDailyAmount(e, o) { if (!currentProtocol) return; const t = currentProtocol.steps[e - 1]; if (!t) return; t.dailyAmount = new Decimal(o); const n = "B" === t.food ? currentProtocol.foodB : currentProtocol.foodA; if (t.method === Method.DIRECT) t.targetMg = t.dailyAmount.times(n.mgPerUnit); else { const e = t.mixFoodAmount.times(n.mgPerUnit); if (t.servings = e.dividedBy(t.targetMg), n.type === FoodType.SOLID) { const e = t.dailyAmount.times(t.servings); t.mixWaterAmount = e } else { const e = t.dailyAmount.times(t.servings); t.mixWaterAmount = e.minus(t.mixFoodAmount) } } renderProtocolTable(), updateWarnings() } function updateStepMixFoodAmount(e, o) { if (!currentProtocol) return; const t = currentProtocol.steps[e - 1]; if (!t || t.method !== Method.DILUTE) return; t.mixFoodAmount = new Decimal(o); const n = "B" === t.food ? currentProtocol.foodB : currentProtocol.foodA, r = t.mixFoodAmount.times(n.mgPerUnit); if (t.servings = r.dividedBy(t.targetMg), n.type === FoodType.SOLID) { const e = t.dailyAmount.times(t.servings); t.mixWaterAmount = e } else { const e = t.dailyAmount.times(t.servings); t.mixWaterAmount = e.minus(t.mixFoodAmount) } renderProtocolTable(), updateWarnings() } function addStepAfter(e) { if (!currentProtocol) return; const o = currentProtocol.steps[e - 1]; if (!o) return; const t = { stepIndex: o.stepIndex + 1, targetMg: o.targetMg, method: o.method, dailyAmount: o.dailyAmount, dailyAmountUnit: o.dailyAmountUnit, food: o.food }; o.method === Method.DILUTE && (t.mixFoodAmount = o.mixFoodAmount, t.mixWaterAmount = o.mixWaterAmount, t.servings = o.servings), currentProtocol.steps.splice(e, 0, t); for (let e = 0; e < currentProtocol.steps.length; e++)currentProtocol.steps[e].stepIndex = e + 1; renderProtocolTable(), updateWarnings() } function removeStep(e) { if (currentProtocol && !(currentProtocol.steps.length <= 1)) { currentProtocol.steps.splice(e - 1, 1); for (let e = 0; e < currentProtocol.steps.length; e++)currentProtocol.steps[e].stepIndex = e + 1; renderProtocolTable(), updateWarnings() } } function toggleFoodType(e) { if (console.log(`toggleFoodType called with isFoodB=${e}`), !currentProtocol) return; const o = e ? currentProtocol.foodB : currentProtocol.foodA; o.type, FoodType.LIQUID; o.type = o.type === FoodType.SOLID ? FoodType.LIQUID : FoodType.SOLID; for (const t of currentProtocol.steps) { if ("B" === t.food === e) if (t.method === Method.DILUTE) { t.dailyAmountUnit = "ml"; const e = t.mixFoodAmount.times(o.mgPerUnit); if (t.servings = e.dividedBy(t.targetMg), o.type === FoodType.SOLID) { const e = t.dailyAmount.times(t.servings); t.mixWaterAmount = e } else { const e = t.dailyAmount.times(t.servings); t.mixWaterAmount = e.minus(t.mixFoodAmount) } } else t.dailyAmountUnit = o.type === FoodType.SOLID ? "g" : "ml" } renderFoodSettings(), renderProtocolTable(), updateWarnings() } function renderFoodSettings() { if (!currentProtocol) return; const e = document.querySelector(".food-a-container"), o = document.querySelector(".food-b-container"); let t = `\n    <div class="food-a-settings">\n      <input\n        type="text"\n        class="food-name-input"\n        id="food-a-name"\n        value="${escapeHtml(currentProtocol.foodA.name)}"\n      />\n      <div class="setting-row">\n        <label>Protein:</label>\n        <input\n          type="number"\n          min="0"\n          id="food-a-protein"\n          value="${mgPerUnitToMgPer100(currentProtocol.foodA.mgPerUnit).toFixed(1)}"\n          step="0.1"\n        />\n        <span>g per 100 ${currentProtocol.foodA.type === FoodType.SOLID ? "g" : "ml"}</span>\n      </div>\n      <div class="setting-row">\n        <label>Form:</label>\n        <div class="toggle-group">\n          <button class="toggle-btn ${currentProtocol.foodA.type === FoodType.SOLID ? "active" : ""}" data-action="toggle-food-a-solid">Solid</button>\n          <button class="toggle-btn ${currentProtocol.foodA.type === FoodType.LIQUID ? "active" : ""}" data-action="toggle-food-a-liquid">Liquid</button>\n        </div>\n      </div>\n      <div class="setting-row">\n        <label>Dilution strategy:</label>\n        <div class="toggle-group">\n          <button class="toggle-btn ${currentProtocol.foodAStrategy === FoodAStrategy.DILUTE_INITIAL ? "active" : ""}" data-action="food-a-strategy-initial">Initial dilution</button>\n          <button class="toggle-btn ${currentProtocol.foodAStrategy === FoodAStrategy.DILUTE_ALL ? "active" : ""}" data-action="food-a-strategy-all">Dilution throughout</button>\n          <button class="toggle-btn ${currentProtocol.foodAStrategy === FoodAStrategy.DILUTE_NONE ? "active" : ""}" data-action="food-a-strategy-none">No dilutions</button>\n        </div>\n      </div>\n      ${currentProtocol.foodAStrategy === FoodAStrategy.DILUTE_INITIAL ? `\n      <div class="setting-row threshold-setting">\n        <label>Directly dose when neat amount ≥</label>\n        <input\n          type="number"\n          id="food-a-threshold"\n          min="0"\n          value="${formatAmount(currentProtocol.diThreshold, currentProtocol.foodA.type === FoodType.SOLID ? "g" : "ml")}"\n          step="0.1"\n        />\n        <span>${currentProtocol.foodA.type === FoodType.SOLID ? "g" : "ml"}</span>\n      </div>\n      ` : ""}\n    </div>\n  `; const n = e.querySelector(".food-a-settings"); if (n ? n.outerHTML = t : e.insertAdjacentHTML("beforeend", t), currentProtocol.foodB) { let e = `\n      <div class="food-b-settings">\n        <input\n          type="text"\n          class="food-name-input"\n          id="food-b-name"\n          value="${escapeHtml(currentProtocol.foodB.name)}"\n        />\n        <div class="setting-row">\n          <label>Protein:</label>\n          <input\n            type="number"\n            id="food-b-protein"\n            min="0"\n            value="${mgPerUnitToMgPer100(currentProtocol.foodB.mgPerUnit).toFixed(1)}"\n            step="0.1"\n          />\n          <span>g per 100 ${currentProtocol.foodB.type === FoodType.SOLID ? "g" : "ml"}</span>\n        </div>\n        <div class="setting-row">\n          <label>Form:</label>\n          <div class="toggle-group">\n            <button class="toggle-btn ${currentProtocol.foodB.type === FoodType.SOLID ? "active" : ""}" data-action="toggle-food-b-solid">Solid</button>\n            <button class="toggle-btn ${currentProtocol.foodB.type === FoodType.LIQUID ? "active" : ""}" data-action="toggle-food-b-liquid">Liquid</button>\n          </div>\n        </div>\n        <div class="setting-row threshold-setting">\n          <label>Transition when amount of food ≥</label>\n          <input\n            type="number"\n            id="food-b-threshold"\n            value="${formatAmount(currentProtocol.foodBThreshold.amount, currentProtocol.foodBThreshold.unit)}"\n            step="0.1"\n            min="0"\n          />\n          <span>${currentProtocol.foodBThreshold.unit}</span>\n        </div>\n      </div>\n    `; const t = o.querySelector(".food-b-settings"); t ? t.outerHTML = e : o.insertAdjacentHTML("beforeend", e) } else { const e = o.querySelector(".food-b-settings"); e && e.remove() } attachSettingsEventListeners() } function renderDosingStrategy() { if (!currentProtocol) return; const e = document.querySelector(".dosing-strategy-container"), o = `\n    <h3>Dosing Strategy (resets all steps on change)</h3>\n    <div class="setting-row">\n      <div class="toggle-group">\n        <button class="toggle-btn ${currentProtocol.dosingStrategy === DosingStrategy.STANDARD ? "active" : ""}" data-strategy="STANDARD">Standard</button>\n        <button class="toggle-btn ${currentProtocol.dosingStrategy === DosingStrategy.SLOW ? "active" : ""}" data-strategy="SLOW">Slow</button>\n        <button class="toggle-btn ${currentProtocol.dosingStrategy === DosingStrategy.RAPID ? "active" : ""}" data-strategy="RAPID">Rapid</button>\n      </div>\n    </div>\n  `; e.innerHTML = o, e.querySelectorAll("[data-strategy]").forEach((e => { e.addEventListener("click", (e => { const o = e.target.getAttribute("data-strategy"); currentProtocol && o !== currentProtocol.dosingStrategy && (currentProtocol.dosingStrategy = o, recalculateProtocol(), renderDosingStrategy()) })) })) } function renderProtocolTable() { if (!currentProtocol) return; const e = document.querySelector(".output-container table"); let o = "\n    <thead>\n      <tr>\n        <th>Step</th>\n        <th>Protein (mg)</th>\n        <th>Method</th>\n        <th>Daily amount</th>\n        <th>Amount for mixture</th>\n        <th>Water for mixture</th>\n      </tr>\n    </thead>\n    <tbody>\n  "; getFoodAStepCount(currentProtocol); let t = !0; for (const e of currentProtocol.steps) { const n = "B" === e.food, r = n ? currentProtocol.foodB : currentProtocol.foodA; if (n && t ? (o += `\n        <tr class="food-section-header">\n          <td colspan="6">${escapeHtml(currentProtocol.foodB.name)}</td>\n        </tr>\n      `, t = !1) : n || 1 !== e.stepIndex || (o += `\n        <tr class="food-section-header">\n          <td colspan="6">${escapeHtml(currentProtocol.foodA.name)}</td>\n        </tr>\n      `), o += "<tr>", o += `\n      <td class="actions-cell">\n        <button class="btn-add-step" data-step="${e.stepIndex}">+</button>\n        <button class="btn-remove-step" data-step="${e.stepIndex}">−</button>\n        <span class="step-number">${e.stepIndex}</span>\n      </td>\n    `, o += `\n      <td>\n        <input\n          class="editable"\n          type="number"\n          data-step="${e.stepIndex}"\n          data-field="targetMg"\n          value="${formatNumber(e.targetMg, 1)}"\n          step="0.1"\n          min="0"\n        />\n      </td>\n    `, o += `\n      <td class="method-cell">${e.method}</td>\n    `, o += `\n      <td>\n        <input\n          class="editable"\n          type="number"\n          data-step="${e.stepIndex}"\n          data-field="dailyAmount"\n          value="${formatAmount(e.dailyAmount, e.dailyAmountUnit)}"\n          step="0.1"\n          min="0"\n        />\n        <span> ${e.dailyAmountUnit}</span>\n      </td>\n    `, e.method === Method.DILUTE) { const t = r.type === FoodType.SOLID ? "g" : "ml"; o += `\n        <td>\n          <input\n            class="editable"\n            type="number"\n            data-step="${e.stepIndex}"\n            data-field="mixFoodAmount"\n            min="0"\n            value="${formatAmount(e.mixFoodAmount, t)}"\n            step="0.01"\n          />\n          <span> ${t}</span>\n        </td>\n      ` } else o += '<td class="na-cell">n/a</td>'; e.method === Method.DILUTE ? o += `\n        <td class="non-editable">\n          ${formatAmount(e.mixWaterAmount, "ml")} ml\n          <span style="color: var(--oit-text-secondary); font-size: 0.85rem;"> (${formatNumber(e.servings, 1)} servings)</span>\n        </td>\n      ` : o += '<td class="na-cell">n/a</td>', o += "</tr>" } o += "</tbody>", e.innerHTML = o; const n = document.querySelector(".bottom-section"); if (!n.querySelector(".export-container")) { const e = `\n      <div class="export-container">\n        <div class="export-buttons">\n          <button class="btn-export" id="export-ascii">Export ASCII</button>\n          <button class="btn-export" id="export-pdf">Export PDF</button>\n        </div>\n        <div class="custom-note-container">\n          <label for="custom-note">Notes:</label>\n          <textarea\n            id="custom-note"\n            class="custom-note-textarea"\n            placeholder="Add any custom notes or instructions for this protocol..."\n            rows="10"\n          >${escapeHtml(customNote)}</textarea>\n        </div>\n      </div>\n    `; n.insertAdjacentHTML("afterbegin", e) } attachTableEventListeners(), attachExportEventListeners(), attachCustomNoteListener() } function updateWarnings() { if (!currentProtocol) return; const e = validateProtocol(currentProtocol), o = document.querySelector(".warnings-container"); if (0 === e.length) return void (o.innerHTML = '\n      <div class="no-warnings">✓ Protocol valid. See here for the issues we check for.<br></div>\n    '); const t = e.filter((e => "red" === e.severity)), n = e.filter((e => "yellow" === e.severity)); let r = ""; t.length > 0 && (r += `\n      <div class="warning-section red-warnings">\n        <h4>Critical Issues (Red)</h4>\n        <ul>\n          ${t.map((e => `<li><strong>${e.message}</strong></li>`)).join("")}\n        </ul>\n      </div>\n    `), n.length > 0 && (r += `\n      <div class="warning-section yellow-warnings">\n        <h4>Cautions (Yellow)</h4>\n        <ul>\n          ${n.map((e => `<li>${e.message}</li>`)).join("")}\n        </ul>\n      </div>\n    `), o.innerHTML = r } function performSearch(e, o) { if (!e.trim()) return []; if ("protocol" === o) { return fuzzysort.go(e, fuzzySortPreparedFoods, { key: "Food", limit: 50, threshold: -1e4 }) } { const o = fuzzysort.go(e, fuzzySortPreparedFoods, { key: "Food", limit: 25, threshold: -1e4 }); return [...fuzzysort.go(e, fuzzySortPreparedProtocols, { key: "name", limit: 25, threshold: -1e4 }), ...o] } } function showSearchDropdown(e, o, t) { const n = document.getElementById(e).parentElement, r = n.querySelector(".search-dropdown"); if (r && r.remove(), 0 === o.length && !t.trim()) return; const d = document.createElement("div"); d.className = "search-dropdown", currentDropdownIndex = -1, currentDropdownInputId = e; const a = document.createElement("div"); a.className = "search-result-item", a.setAttribute("data-index", "0"), a.innerHTML = `<strong>Custom:</strong> ${escapeHtml(t || "New food")}`, a.addEventListener("click", (() => { selectCustomFood(t || "New Food", e), hideSearchDropdown(e) })), d.appendChild(a); const s = o.slice(0, 50); for (let o = 0; o < s.length; o++) { const t = s[o], n = document.createElement("div"); if (n.className = "search-result-item", n.setAttribute("data-index", String(o + 1)), t.obj.name) n.innerHTML = `<strong>Protocol:</strong> ${escapeHtml(t.obj.name)}`, n.addEventListener("click", (() => { selectProtocol(t.obj), hideSearchDropdown(e) })); else { const o = t.obj; n.innerHTML = `\n        ${escapeHtml(o.Food)}\n        <span class="food-type"> - ${escapeHtml(o.Type)} - Protein: ${o["Mean value in 100g"].toFixed(1)} g/100 ${"Solid" === o.Type ? "g" : "ml"}</span>\n      `, n.addEventListener("click", (() => { "food-a-search" === e ? selectFoodA(o) : selectFoodB(o), hideSearchDropdown(e) })) } d.appendChild(n) } n.appendChild(d) } function hideSearchDropdown(e) { const o = document.getElementById(e).parentElement.querySelector(".search-dropdown"); o && o.remove(), currentDropdownIndex = -1, currentDropdownInputId = "" } function navigateDropdown(e) { if (!currentDropdownInputId) return; const o = document.getElementById(currentDropdownInputId); if (!o) return; const t = o.parentElement.querySelector(".search-dropdown"); if (!t) return; const n = Array.from(t.querySelectorAll(".search-result-item")); 0 !== n.length && (currentDropdownIndex >= 0 && currentDropdownIndex < n.length && n[currentDropdownIndex].classList.remove("highlighted"), currentDropdownIndex = "down" === e ? (currentDropdownIndex + 1) % n.length : currentDropdownIndex <= 0 ? n.length - 1 : currentDropdownIndex - 1, n[currentDropdownIndex].classList.add("highlighted"), n[currentDropdownIndex].scrollIntoView({ block: "nearest", behavior: "smooth" })) } function selectHighlightedDropdownItem() { if (!currentDropdownInputId || currentDropdownIndex < 0) return; const e = document.getElementById(currentDropdownInputId); if (!e) return; const o = e.parentElement.querySelector(".search-dropdown"); if (!o) return; const t = Array.from(o.querySelectorAll(".search-result-item")); currentDropdownIndex < t.length && t[currentDropdownIndex].click() } function selectFoodA(e) { const o = { name: e.Food, type: "Solid" === e.Type ? FoodType.SOLID : FoodType.LIQUID, mgPerUnit: mgPer100ToMgPerUnit(e["Mean value in 100g"], "Solid" === e.Type ? "g" : "ml") }; currentProtocol = generateDefaultProtocol(o, DEFAULT_CONFIG), renderFoodSettings(), renderDosingStrategy(), renderProtocolTable(), updateWarnings(), updateFoodBDisabledState(), document.getElementById("food-a-search").value = "" } function selectFoodB(e) { if (!currentProtocol) return; const o = { name: e.Food, type: "Solid" === e.Type ? FoodType.SOLID : FoodType.LIQUID, mgPerUnit: mgPer100ToMgPerUnit(e["Mean value in 100g"], "Solid" === e.Type ? "g" : "ml") }, t = { unit: o.type === FoodType.SOLID ? "g" : "ml", amount: DEFAULT_CONFIG.DEFAULT_FOOD_B_THRESHOLD }; addFoodBToProtocol(currentProtocol, o, t), renderFoodSettings(), renderProtocolTable(), updateWarnings(), document.getElementById("food-b-search").value = "" } function selectCustomFood(e, o) { const t = { name: e || "Custom Food", type: FoodType.SOLID, mgPerUnit: mgPer100ToMgPerUnit(10, "g") }; if ("food-a-search" === o) currentProtocol = generateDefaultProtocol(t, DEFAULT_CONFIG), renderFoodSettings(), renderDosingStrategy(), renderProtocolTable(), updateWarnings(), updateFoodBDisabledState(); else { if (!currentProtocol) return; const e = { unit: "g", amount: DEFAULT_CONFIG.DEFAULT_FOOD_B_THRESHOLD }; addFoodBToProtocol(currentProtocol, t, e), renderFoodSettings(), renderProtocolTable(), updateWarnings() } document.getElementById(o).value = "" } function selectProtocol(e) { const o = { name: e.food_a.name, type: "SOLID" === e.food_a.type ? FoodType.SOLID : FoodType.LIQUID, mgPerUnit: new Decimal(e.food_a.mgPerUnit) }, t = { dosingStrategy: DosingStrategy[e.dosing_strategy], foodA: o, foodAStrategy: FoodAStrategy[e.food_a_strategy], diThreshold: new Decimal(e.di_threshold), steps: [], config: DEFAULT_CONFIG }; let n; e.custom_note && (customNote = e.custom_note), t.foodAStrategy === FoodAStrategy.DILUTE_INITIAL ? n = e.table_di : t.foodAStrategy === FoodAStrategy.DILUTE_NONE ? n = e.table_dn : t.foodAStrategy === FoodAStrategy.DILUTE_ALL && (n = e.table_da); for (let e = 0; e < n.length; e++) { const r = n[e], d = { stepIndex: e + 1, targetMg: new Decimal(r.protein), method: "DILUTE" === r.method ? Method.DILUTE : Method.DIRECT, dailyAmount: new Decimal(r.daily_amount), dailyAmountUnit: "DILUTE" === r.method ? "ml" : r.food === o.name ? o.type === FoodType.SOLID ? "g" : "ml" : "g", food: r.food === o.name ? "A" : "B" }; if ("DILUTE" === r.method) { d.mixFoodAmount = new Decimal(r.mix_amount), d.mixWaterAmount = new Decimal(r.water_amount); const e = r.food === o.name ? o : t.foodB, n = d.mixFoodAmount.times(e.mgPerUnit); d.servings = n.dividedBy(d.targetMg) } t.steps.push(d) } e.food_b && (t.foodB = { name: e.food_b.name, type: "SOLID" === e.food_b.type ? FoodType.SOLID : FoodType.LIQUID, mgPerUnit: new Decimal(e.food_b.mgPerUnit) }, e.food_b_threshold && (t.foodBThreshold = { unit: t.foodB.type === FoodType.SOLID ? "g" : "ml", amount: new Decimal(e.food_b_threshold) })), currentProtocol = t, renderFoodSettings(), renderDosingStrategy(), renderProtocolTable(), updateWarnings(), updateFoodBDisabledState(), document.getElementById("food-a-search").value = "" } function clearFoodB() { currentProtocol && (currentProtocol.foodB = void 0, currentProtocol.foodBThreshold = void 0, recalculateProtocol(), renderFoodSettings(), renderProtocolTable(), updateWarnings()) } function updateFoodBDisabledState() { const e = document.querySelector(".food-b-container"); if (!e) return; if (currentProtocol && currentProtocol.foodA) { e.classList.remove("disabled"); const o = document.getElementById("food-b-search"), t = document.getElementById("clear-food-b"); o && (o.disabled = !1), t && (t.disabled = !1) } else { e.classList.add("disabled"); const o = document.getElementById("food-b-search"), t = document.getElementById("clear-food-b"); o && (o.disabled = !0, o.value = ""), t && (t.disabled = !0) } } function attachSettingsEventListeners() { const e = document.getElementById("food-a-name"); e && e.addEventListener("input", (e => { currentProtocol && (currentProtocol.foodA.name = e.target.value, renderProtocolTable()) })); const o = document.getElementById("food-a-protein"); o && o.addEventListener("change", (e => { if (currentProtocol) { const o = parseFloat(e.target.value), t = currentProtocol.foodA.type === FoodType.SOLID ? "g" : "ml"; currentProtocol.foodA.mgPerUnit = mgPer100ToMgPerUnit(o, t), recalculateStepMethods() } })); const t = document.getElementById("food-a-threshold"); t && t.addEventListener("change", (e => { currentProtocol && (currentProtocol.diThreshold = new Decimal(e.target.value), recalculateStepMethods()) })); const n = document.getElementById("food-b-name"); n && n.addEventListener("input", (e => { currentProtocol && currentProtocol.foodB && (currentProtocol.foodB.name = e.target.value, renderProtocolTable()) })); const r = document.getElementById("food-b-protein"); r && r.addEventListener("change", (e => { if (currentProtocol && currentProtocol.foodB) { const o = parseFloat(e.target.value), t = currentProtocol.foodB.type === FoodType.SOLID ? "g" : "ml"; if (currentProtocol.foodB.mgPerUnit = mgPer100ToMgPerUnit(o, t), currentProtocol.foodBThreshold) { const e = currentProtocol.foodB, o = currentProtocol.foodBThreshold; currentProtocol.foodB = void 0, currentProtocol.foodBThreshold = void 0, recalculateProtocol(), addFoodBToProtocol(currentProtocol, e, o), renderProtocolTable(), updateWarnings() } } })); const d = document.getElementById("food-b-threshold"); d && d.addEventListener("change", (e => { if (currentProtocol && currentProtocol.foodB && currentProtocol.foodBThreshold) { currentProtocol.foodBThreshold.amount = new Decimal(e.target.value); const o = currentProtocol.foodB, t = currentProtocol.foodBThreshold; currentProtocol.foodB = void 0, currentProtocol.foodBThreshold = void 0, recalculateProtocol(), addFoodBToProtocol(currentProtocol, o, t), renderProtocolTable(), updateWarnings() } })), document.querySelectorAll("[data-action]").forEach((e => { e.addEventListener("click", (e => { const o = e.target.getAttribute("data-action"); if (currentProtocol) switch (o) { case "toggle-food-a-solid": currentProtocol.foodA.type !== FoodType.SOLID && toggleFoodType(!1); break; case "toggle-food-a-liquid": currentProtocol.foodA.type !== FoodType.LIQUID && toggleFoodType(!1); break; case "toggle-food-b-solid": currentProtocol.foodB && currentProtocol.foodB.type !== FoodType.SOLID && toggleFoodType(!0); break; case "toggle-food-b-liquid": currentProtocol.foodB && currentProtocol.foodB.type !== FoodType.LIQUID && toggleFoodType(!0); break; case "food-a-strategy-initial": currentProtocol.foodAStrategy = FoodAStrategy.DILUTE_INITIAL, recalculateStepMethods(), renderFoodSettings(); break; case "food-a-strategy-all": currentProtocol.foodAStrategy = FoodAStrategy.DILUTE_ALL, recalculateStepMethods(), renderFoodSettings(); break; case "food-a-strategy-none": currentProtocol.foodAStrategy = FoodAStrategy.DILUTE_NONE, recalculateStepMethods(), renderFoodSettings() } })) })) } function attachTableEventListeners() { document.querySelectorAll("input.editable").forEach((e => { e.addEventListener("blur", (e => { const o = e.target, t = parseInt(o.getAttribute("data-step")), n = o.getAttribute("data-field"), r = parseFloat(o.value); isNaN(r) || ("targetMg" === n ? updateStepTargetMg(t, r) : "dailyAmount" === n ? updateStepDailyAmount(t, r) : "mixFoodAmount" === n && updateStepMixFoodAmount(t, r)) })), e.addEventListener("keydown", (e => { "Enter" === e.key && e.target.blur() })) })), document.querySelectorAll(".btn-add-step").forEach((e => { e.addEventListener("click", (e => { addStepAfter(parseInt(e.target.getAttribute("data-step"))) })) })), document.querySelectorAll(".btn-remove-step").forEach((e => { e.addEventListener("click", (e => { removeStep(parseInt(e.target.getAttribute("data-step"))) })) })) } function attachExportEventListeners() { const e = document.getElementById("export-ascii"); e && e.addEventListener("click", exportASCII); const o = document.getElementById("export-pdf"); o && o.addEventListener("click", exportPDF) } function attachCustomNoteListener() { const e = document.getElementById("custom-note"); if (!e) return; e.value = customNote; let o = null; e.addEventListener("input", (e => { null !== o && clearTimeout(o), o = window.setTimeout((() => { const o = e.target.value, t = document.createElement("div"); t.textContent = o, customNote = t.textContent || "" }), 300) })) } function exportPDF() { if (!currentProtocol) return; const { jsPDF: e } = jspdf, o = new e({ unit: "pt", format: "letter" }); let t = 40; o.setFontSize(18), o.setFont(void 0, "bold"), o.text("Oral Immunotherapy Protocol", 40, t), t += 30; currentProtocol.foodA.type, FoodType.SOLID; const n = currentProtocol.foodA.type === FoodType.SOLID ? "g" : "ml", r = getFoodAStepCount(currentProtocol), d = currentProtocol.steps.length, a = []; for (let e = 0; e < r; e++) { const o = currentProtocol.steps[e], t = currentProtocol.foodA; let n = `${formatAmount(o.dailyAmount, o.dailyAmountUnit)} ${o.dailyAmountUnit}`, r = "N/A"; if (o.method === Method.DILUTE) { const e = t.type === FoodType.SOLID ? "g" : "ml"; r = `${formatAmount(o.mixFoodAmount, e)} ${e} food + ${formatAmount(o.mixWaterAmount, "ml")} ml water` } a.push([o.stepIndex, `${formatNumber(o.targetMg, 1)} mg`, o.method, n, r, "2-4 weeks"]) } if (o.setFontSize(14), o.setFont(void 0, "bold"), o.text(`${currentProtocol.foodA.name}`, 40, t), t += 20, o.setFontSize(10), o.setFont(void 0, "normal"), o.text(`Protein: ${formatNumber(currentProtocol.foodA.mgPerUnit.dividedBy(new Decimal(10)), 2)} g per 100 ${n} serving.`, 40, t), t += 15, o.autoTable({ startY: t, head: [["Step", "Protein", "Method", "Daily Amount", "How to make mix", "Interval"]], body: a, theme: "grid", headStyles: { fillColor: [66, 139, 202], fontStyle: "bold" }, margin: { left: 40, right: 40 }, styles: { fontSize: 9, cellPadding: 5 }, columnStyles: { 0: { cellWidth: 40 }, 1: { cellWidth: 70 }, 2: { cellWidth: 60 }, 3: { cellWidth: 90 }, 4: { cellWidth: 180 }, 5: { cellWidth: 80 } } }), t = o.lastAutoTable.finalY + 20, currentProtocol.foodB && r < d) { currentProtocol.foodB.type, FoodType.SOLID; const e = currentProtocol.foodB.type === FoodType.SOLID ? "g" : "ml", n = []; for (let e = r; e < d; e++) { const o = currentProtocol.steps[e], t = currentProtocol.foodB; let r = `${formatAmount(o.dailyAmount, o.dailyAmountUnit)} ${o.dailyAmountUnit}`, d = "N/A"; if (o.method === Method.DILUTE) { const e = t.type === FoodType.SOLID ? "g" : "ml"; d = `${formatAmount(o.mixFoodAmount, e)} ${e} food + ${formatAmount(o.mixWaterAmount, "ml")} ml water` } n.push([o.stepIndex, `${formatNumber(o.targetMg, 1)} mg`, o.method, r, d, "2-4 weeks"]) } t > 650 && (o.addPage(), t = 40), t += 10, o.setFontSize(14), o.setFont(void 0, "bold"), o.text(`${currentProtocol.foodB.name}`, 40, t), t += 20, o.setFontSize(10), o.setFont(void 0, "normal"), o.text(`Protein: ${formatNumber(currentProtocol.foodB.mgPerUnit.dividedBy(new Decimal(10)), 2)} g per 100 ${e} serving`, 40, t), t += 15, o.autoTable({ startY: t, head: [["Step", "Protein", "Method", "Daily Amount", "How to make mix", "Interval"]], body: n, theme: "grid", headStyles: { fillColor: [66, 139, 202], fontStyle: "bold" }, margin: { left: 40, right: 40 }, styles: { fontSize: 9, cellPadding: 5 }, columnStyles: { 0: { cellWidth: 40 }, 1: { cellWidth: 70 }, 2: { cellWidth: 60 }, 3: { cellWidth: 90 }, 4: { cellWidth: 180 }, 5: { cellWidth: 80 } } }), t = o.lastAutoTable.finalY + 20 } if (customNote && customNote.trim()) { t > 650 && (o.addPage(), t = 40), o.setFontSize(14), o.setFont(void 0, "bold"), o.text("Notes", 40, t), t += 15, o.setFontSize(10), o.setFont(void 0, "normal"); const e = 520, n = o.splitTextToSize(customNote.trim(), e); for (const e of n) t > 730 && (o.addPage(), t = 40), o.text(e, 40, t), t += 14 } const s = o.internal.getNumberOfPages(); for (let e = 1; e <= s; e++)o.setPage(e), o.setFontSize(8), o.setFont(void 0, "italic"), o.setTextColor(100), o.text("", 40, 760), o.text("Always verify calculations before clinical use.", 40, 772), o.setTextColor(0); const i = o.output("dataurlstring"), l = window.open("", "_blank"); l ? l.document.write(`<iframe src="${i}" style="width:100%; height:100%; border:none;"></iframe>`) : alert("Popup blocked. Please allow popups to view the PDF.") } function exportASCII() { if (!currentProtocol) return; let e = "", o = "", t = ""; const n = currentProtocol.foodA.type === FoodType.SOLID ? "Solid" : "Liquid", r = currentProtocol.foodA.type === FoodType.SOLID ? "g" : "ml"; if (o += `${currentProtocol.foodA.name} (${n}). Protein: ${formatNumber(currentProtocol.foodA.mgPerUnit, 1)} mg/${r}`, currentProtocol.foodB) { const e = currentProtocol.foodB.type === FoodType.SOLID ? "Solid" : "Liquid", o = currentProtocol.foodB.type === FoodType.SOLID ? "g" : "ml"; t += `${currentProtocol.foodB.name} (${e}). Protein: ${formatNumber(currentProtocol.foodB.mgPerUnit, 1)} mg/${o}` } const d = currentProtocol.steps.length, a = getFoodAStepCount(currentProtocol), s = new AsciiTable(o), i = new AsciiTable(t); s.setHeading("Step", "Protein", "Method", "Daily Amount", "Mix Details"), i.setHeading("Step", "Protein", "Method", "Daily Amount", "Mix Details"); for (const e of currentProtocol.steps) { const o = "B" === e.food, t = o ? currentProtocol.foodB : currentProtocol.foodA; let n; n = o ? i : s; let r = `${formatAmount(e.dailyAmount, e.dailyAmountUnit)} ${e.dailyAmountUnit}`, d = "N/A"; if (e.method === Method.DILUTE) { const o = t.type === FoodType.SOLID ? "g" : "ml"; d = `${formatAmount(e.mixFoodAmount, o)} ${o} food + ${formatAmount(e.mixWaterAmount, "ml")} ml water` } n.addRow(e.stepIndex, `${formatNumber(e.targetMg, 1)} mg`, e.method, r, d) } a > 0 && (e += s.toString() + "\n\n"), a < d && (e += "--- TRANSITION TO: ---\n", e += i.toString() + "\n\n"), customNote && customNote.trim() && (e += "========================================\n", e += "NOTES\n", e += "========================================\n", e += `${customNote.trim()}`), navigator.clipboard.writeText(e).catch((() => { alert("Failed to copy to clipboard. Please copy manually:\n\n" + e) })) } async function loadDatabases() { try { const e = await fetch("/tool_assets/typed_foods_rough.json"); foodsDatabase = await e.json(), fuzzySortPreparedFoods = foodsDatabase.map((e => Object.assign(Object.assign({}, e), { prepared: fuzzysort.prepare(e.Food) }))); const o = await fetch("/tool_assets/oit_protocols.json"); protocolsDatabase = await o.json(), fuzzySortPreparedProtocols = protocolsDatabase.map((e => Object.assign(Object.assign({}, e), { prepared: fuzzysort.prepare(e.name) }))), console.log(`Loaded ${foodsDatabase.length} foods and ${protocolsDatabase.length} protocols`) } catch (e) { console.error("Error loading databases:", e), alert("Error loading food and protocol databases. Some features may not work.") } } async function initializeCalculator() { await loadDatabases(); const e = document.getElementById("food-a-search"); e && (e.addEventListener("input", (e => { const o = e.target.value; searchDebounceTimer && clearTimeout(searchDebounceTimer), searchDebounceTimer = window.setTimeout((() => { showSearchDropdown("food-a-search", performSearch(o, "food"), o) }), 150) })), e.addEventListener("keydown", (o => { var t; (null === (t = e.parentElement) || void 0 === t ? void 0 : t.querySelector(".search-dropdown")) && ("ArrowDown" === o.key ? (o.preventDefault(), navigateDropdown("down")) : "ArrowUp" === o.key ? (o.preventDefault(), navigateDropdown("up")) : "Enter" === o.key ? (o.preventDefault(), selectHighlightedDropdownItem()) : "Escape" === o.key && hideSearchDropdown("food-a-search")) })), e.addEventListener("blur", (() => { setTimeout((() => hideSearchDropdown("food-a-search")), 200) }))); const o = document.getElementById("food-b-search"); o && (o.addEventListener("input", (e => { const o = e.target.value; searchDebounceTimer && clearTimeout(searchDebounceTimer), searchDebounceTimer = window.setTimeout((() => { showSearchDropdown("food-b-search", performSearch(o, "protocol"), o) }), 150) })), o.addEventListener("keydown", (e => { var t; (null === (t = o.parentElement) || void 0 === t ? void 0 : t.querySelector(".search-dropdown")) && ("ArrowDown" === e.key ? (e.preventDefault(), navigateDropdown("down")) : "ArrowUp" === e.key ? (e.preventDefault(), navigateDropdown("up")) : "Enter" === e.key ? (e.preventDefault(), selectHighlightedDropdownItem()) : "Escape" === e.key && hideSearchDropdown("food-b-search")) })), o.addEventListener("blur", (() => { setTimeout((() => hideSearchDropdown("food-b-search")), 200) }))); const t = document.getElementById("clear-food-b"); t && t.addEventListener("click", clearFoodB), updateFoodBDisabledState(), console.log("OIT Calculator initialized") } "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", initializeCalculator) : initializeCalculator();
